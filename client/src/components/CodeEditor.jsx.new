import React, { useRef, useEffect, useState, useCallback } from 'react';
import Editor from '@monaco-editor/react';
import SpecialCharactersBar from './SpecialCharactersBar';
import { useRoom } from '../contexts/RoomContext';
import { debounce } from '../utils/helpers';
import { Maximize2, Minimize2, Expand, Eraser } from 'lucide-react';
import MonacoYjsBinding from './MonacoYjsBinding';
import { v4 as uuidv4 } from 'uuid';

// Helper function to generate random colors for user cursors
const getRandomColor = () => {
  const colors = [
    '#FF6B6B', '#4ECDC4', '#FFE66D', '#1A535C', '#F9C80E', 
    '#FF8C42', '#A4036F', '#048BA8', '#16DB93', '#EFBCD5'
  ];
  return colors[Math.floor(Math.random() * colors.length)];
};

// Create a color map to ensure users always get the same color
const userColorMap = new Map();

// Generate a unique client ID for this editor instance
const CLIENT_ID = uuidv4();

// Add a log level setting
const LOG_LEVEL = 'info'; // 'debug', 'info', 'warn', 'error', or 'none'

// Add a custom logger to control verbosity
const logger = {
  debug: (...args) => LOG_LEVEL === 'debug' ? console.debug(...args) : null,
  info: (...args) => ['debug', 'info'].includes(LOG_LEVEL) ? console.info(...args) : null,
  warn: (...args) => ['debug', 'info', 'warn'].includes(LOG_LEVEL) ? console.warn(...args) : null,
  error: (...args) => LOG_LEVEL !== 'none' ? console.error(...args) : null,
};

function CodeEditor({ code, setCode, language, theme, onRunCode, readOnly = false, isFilesPanelOpen = false }) {
  const editorRef = useRef(null);
  const monacoRef = useRef(null);
  const [showCharsBar, setShowCharsBar] = useState(window.innerWidth < 1024);
  const [showSpecialChars, setShowSpecialChars] = useState(false);
  const [isIOS, setIsIOS] = useState(false);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [isBrowserFullscreen, setIsBrowserFullscreen] = useState(false);
  const [isResetConfirmOpen, setIsResetConfirmOpen] = useState(false);
  
  // Get room context
  const { isInRoom, slug, currentUser, yDoc, provider } = useRoom();
  
  // Function to get a consistent color for a user
  const getUserColor = useCallback((userId) => {
    if (!userColorMap.has(userId)) {
      userColorMap.set(userId, getRandomColor());
    }
    return userColorMap.get(userId);
  }, []);

  // Editor mount handler
  const handleEditorDidMount = useCallback((editor, monaco) => {
    editorRef.current = editor;
    monacoRef.current = monaco;
    
    // Set editor options for better appearance
    monaco.editor.defineTheme('customDark', {
      base: 'vs-dark',
      inherit: true,
      rules: [],
      colors: {
        'editor.background': '#1a1b26',
      }
    });
    
    if (theme === 'dark') {
      monaco.editor.setTheme('customDark');
    }
    
    // Add keybinding for running code
    editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.Enter, () => {
      onRunCode();
    });
    
    // Focus editor on mount for desktop, but not for mobile
    if (window.innerWidth >= 768) {
      editor.focus();
    }
    
    // Set read-only state
    editor.updateOptions({ readOnly });

    logger.info("Editor mounted successfully with collaboration enabled");
  }, [theme, onRunCode, readOnly]);

  // Handle code change
  const handleCodeChange = useCallback((newCode) => {
    // When not using Yjs, update the state directly
    if (!yDoc || !provider) {
      setCode(newCode);
    }
  }, [setCode, yDoc, provider]);

  // Force the special characters bar to show on mobile and tablet
  useEffect(() => {
    const checkMobile = () => {
      const isMobileOrTablet = window.innerWidth < 1024;
      setShowCharsBar(isMobileOrTablet);
    };
    
    // Initial check
    checkMobile();
    
    // Re-check on resize
    window.addEventListener('resize', checkMobile);
    return () => window.removeEventListener('resize', checkMobile);
  }, []);

  // Handle insertion of special characters
  const handleSpecialCharInsert = (before, after = '') => {
    // Don't allow insertion in read-only mode
    if (readOnly) return;

    if (editorRef.current) {
      const editor = editorRef.current;
      
      // Focus the editor first to ensure the insertion works properly
      editor.focus();
      
      // Get current selection or cursor position
      const selection = editor.getSelection();
      const id = { major: 1, minor: 1 };
      const text = selection.isEmpty() ? '' : editor.getModel().getValueInRange(selection);
      
      // Create edit operation
      const op = {
        identifier: id,
        range: selection,
        text: before + text + after,
        forceMoveMarkers: true
      };
      
      editor.executeEdits("specialChars", [op]);
      
      // Position cursor between brackets if needed and no text was selected
      if (after && selection.isEmpty()) {
        const position = selection.getPosition();
        const newPosition = {
          lineNumber: position.lineNumber,
          column: position.column + before.length
        };
        editor.setPosition(newPosition);
      }
      
      // Keep focus on editor after insertion
      window.setTimeout(() => {
        editor.focus();
      }, 50);
    }
  };

  // Adjust options based on screen size
  const getEditorOptions = () => {
    const isMobile = window.innerWidth < 768;
    
    return {
      fontSize: isMobile ? 12 : 14,
      fontFamily: '"Fira Code", "Consolas", monospace',
      fontLigatures: true,
      minimap: { enabled: window.innerWidth > 768 },
      scrollBeyondLastLine: false,
      automaticLayout: true,
      tabSize: 2,
      wordWrap: "on",
      padding: { top: 10, bottom: showCharsBar ? 40 : 10 },
      lineNumbers: window.innerWidth > 576 ? 'on' : 'off', // Disable line numbers on very small screens
      folding: !isMobile,
      glyphMargin: !isMobile,
      scrollbar: {
        vertical: 'visible',
        horizontal: 'visible',
        verticalScrollbarSize: 14,
        horizontalScrollbarSize: 14,
        alwaysConsumeMouseWheel: false
      },
      overviewRulerLanes: 0, // Disable overview ruler on mobile
      renderLineHighlightOnlyWhenFocus: true, // Better for mobile performance
      renderWhitespace: 'none', // disables all whitespace highlighting
      readOnly,
      domReadOnly: readOnly,
    };
  };

  // Toggle fullscreen mode
  const toggleFullscreen = () => {
    setIsFullscreen(!isFullscreen);
  };

  // Toggle browser fullscreen mode
  const toggleBrowserFullscreen = () => {
    if (!document.fullscreenElement) {
      document.documentElement.requestFullscreen().catch(err => {
        console.error(`Error attempting to enable full-screen mode: ${err.message}`);
      });
      setIsBrowserFullscreen(true);
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
      setIsBrowserFullscreen(false);
    }
  };

  // Handle ESC key to exit all fullscreen modes
  useEffect(() => {
    const handleKeyDown = (e) => {
      if (e.key === 'Escape') {
        if (isFullscreen) {
          setIsFullscreen(false);
        }
        if (isBrowserFullscreen) {
          setIsBrowserFullscreen(false);
        }
      }
    };
    
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [isFullscreen, isBrowserFullscreen]);

  // Set up iOS detection
  useEffect(() => {
    const isIOSDevice = /iPad|iPhone|iPod/.test(navigator.userAgent) || 
      (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
    setIsIOS(isIOSDevice);
  }, []);

  // Reset editor content
  const resetEditorContent = () => {
    if (editorRef.current) {
      editorRef.current.setValue('');
      setCode('');
      setIsResetConfirmOpen(false);
    }
  };

  // Create CSS classes based on states
  const editorContainerClasses = `
    editor-container 
    ${isFullscreen ? 'fullscreen' : ''} 
    ${isFilesPanelOpen ? 'with-files-panel' : ''} 
    ${showCharsBar ? 'with-chars-bar' : ''}
  `;

  return (
    <div className={editorContainerClasses}>
      {isInRoom && yDoc && provider && (
        <MonacoYjsBinding
          editor={editorRef.current}
          monaco={monacoRef.current}
          yDoc={yDoc}
          awareness={provider.awareness}
          roomId={slug}
          currentUser={currentUser}
          readOnly={readOnly}
        />
      )}

      <div className="editor-header">
        <div className="editor-actions">
          {!readOnly && (
            <button 
              className="editor-btn reset-btn" 
              title="Clear editor content"
              onClick={() => setIsResetConfirmOpen(true)}
            >
              <Eraser size={16} />
            </button>
          )}

          <button 
            className="editor-btn fullscreen-btn" 
            title="Toggle editor fullscreen"
            onClick={toggleFullscreen}
          >
            {isFullscreen ? <Minimize2 size={16} /> : <Maximize2 size={16} />}
          </button>

          <button 
            className="editor-btn browser-fullscreen-btn" 
            title="Toggle browser fullscreen"
            onClick={toggleBrowserFullscreen}
          >
            <Expand size={16} />
          </button>
        </div>
      </div>

      <Editor
        height="100%"
        width="100%"
        language={language}
        value={code}
        theme={theme === 'dark' ? 'customDark' : 'light'}
        onChange={handleCodeChange}
        onMount={handleEditorDidMount}
        options={getEditorOptions()}
        className="monaco-editor-container"
      />

      {showCharsBar && (
        <div className="special-chars-toggle" onClick={() => setShowSpecialChars(!showSpecialChars)}>
          {showSpecialChars ? '▼ Hide Special Characters' : '▲ Show Special Characters'}
        </div>
      )}

      {showCharsBar && showSpecialChars && (
        <div className="special-chars-container">
          <SpecialCharactersBar onInsert={handleSpecialCharInsert} />
        </div>
      )}

      {isResetConfirmOpen && (
        <div className="confirmation-dialog">
          <div className="confirmation-dialog-content">
            <h3>Clear Editor?</h3>
            <p>Are you sure you want to clear all code in the editor? This cannot be undone.</p>
            <div className="confirmation-dialog-actions">
              <button onClick={() => setIsResetConfirmOpen(false)}>Cancel</button>
              <button className="danger" onClick={resetEditorContent}>Clear</button>
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

export default CodeEditor;
