import { createContext, useContext, useReducer, useEffect, useState, useCallback } from 'react';
import { useSelector } from 'react-redux';
import * as Y from 'yjs';
import { WebsocketProvider } from 'y-websocket';
import { useNavigate } from 'react-router-dom';
import io from 'socket.io-client';
import api from '../utils/api';
import { saveToStorage, getFromStorage, removeFromStorage } from '../utils/storage';

// Access level definitions
export const ACCESS_LEVELS = {
  OWNER: 'owner',   // Can edit code, run code, manage users and room settings
  EDITOR: 'editor', // Can edit code and run code
  RUNNER: 'runner', // Can only run code, not edit
  VIEWER: 'viewer', // Can only view code and output
};

// Permission checks
export const canEdit = (accessLevel) => 
  [ACCESS_LEVELS.OWNER, ACCESS_LEVELS.EDITOR].includes(accessLevel);
  
export const canRun = (accessLevel) => 
  [ACCESS_LEVELS.OWNER, ACCESS_LEVELS.EDITOR, ACCESS_LEVELS.RUNNER].includes(accessLevel);
  
export const canManageUsers = (accessLevel) => 
  [ACCESS_LEVELS.OWNER].includes(accessLevel);

// Initial state for room context
const initialState = {
  isInRoom: false,
  slug: null,
  room: {
    name: '',
    description: '',
    language: 'javascript',
    isPublic: false,
    createdAt: null,
    owner: null,
    settings: {
      readOnly: false,
      autoSave: true,
      theme: 'system',
      tabSize: 2,
      wrapLines: true
    },
    expiresAt: null
  },
  users: [],
  currentUser: {
    id: null,
    username: '',
    displayName: '',
    accessLevel: null,
    isOwner: false
  },
  chat: [],
  loading: false,
  error: null,
  connected: false,
  yDoc: null,
  provider: null
};

// Action types for reducer
const ACTION_TYPES = {
  JOIN_ROOM_START: 'JOIN_ROOM_START',
  JOIN_ROOM_SUCCESS: 'JOIN_ROOM_SUCCESS',
  JOIN_ROOM_ERROR: 'JOIN_ROOM_ERROR',
  LEAVE_ROOM: 'LEAVE_ROOM',
  UPDATE_ROOM_DETAILS: 'UPDATE_ROOM_DETAILS',
  UPDATE_USERS: 'UPDATE_USERS',
  UPDATE_CURSORS: 'UPDATE_CURSORS',
  UPDATE_ACCESS_LEVEL: 'UPDATE_ACCESS_LEVEL',
  ADD_CHAT_MESSAGE: 'ADD_CHAT_MESSAGE',
  SET_CONNECTION_STATUS: 'SET_CONNECTION_STATUS',
  SET_ERROR: 'SET_ERROR',
  CLEAR_ERROR: 'CLEAR_ERROR',
};

// Reducer function for room state
const roomReducer = (state, action) => {
  switch (action.type) {
    case ACTION_TYPES.JOIN_ROOM_START:
      return { 
        ...state, 
        loading: true,
        error: null
      };
    
    case ACTION_TYPES.JOIN_ROOM_SUCCESS:
      return {
        ...state,
        isInRoom: true,
        slug: action.payload.slug,
        room: {
          name: action.payload.name,
          description: action.payload.description || '',
          language: action.payload.language || 'javascript',
          isPublic: action.payload.isPublic,
          createdAt: action.payload.createdAt,
          owner: action.payload.owner,
          settings: action.payload.settings,
          expiresAt: action.payload.expiresAt
        },
        users: action.payload.users || [],
        currentUser: {
          ...state.currentUser,
          id: action.payload.currentUser.id,
          accessLevel: action.payload.currentUser.accessLevel,
          isOwner: action.payload.currentUser.isOwner
        },
        loading: false,
        error: null,
        connected: true,
        yDoc: action.payload.yDoc,
        provider: action.payload.provider
      };
      
    case ACTION_TYPES.JOIN_ROOM_ERROR:
      return {
        ...state,
        loading: false,
        error: action.payload,
        connected: false
      };
      
    case ACTION_TYPES.LEAVE_ROOM:
      // Clean up Yjs resources
      if (state.provider) {
        state.provider.disconnect();
      }
      
      return {
        ...initialState,
        currentUser: {
          ...initialState.currentUser,
          id: state.currentUser.id,
          username: state.currentUser.username,
          displayName: state.currentUser.displayName
        }
      };
      
    case ACTION_TYPES.UPDATE_ROOM_DETAILS:
      return {
        ...state,
        room: {
          ...state.room,
          ...action.payload
        }
      };
      
    case ACTION_TYPES.UPDATE_USERS:
      return {
        ...state,
        users: action.payload
      };
      
    case ACTION_TYPES.UPDATE_CURSORS:
      return {
        ...state,
        users: state.users.map(user => 
          user.id === action.payload.userId
            ? { ...user, cursor: action.payload.cursor }
            : user
        )
      };
      
    case ACTION_TYPES.UPDATE_ACCESS_LEVEL:
      // Check if the updated user is the current user
      if (action.payload.userId === state.currentUser.id) {
        console.log(`Updating my access level to ${action.payload.accessLevel}`);
        return {
          ...state,
          currentUser: {
            ...state.currentUser,
            accessLevel: action.payload.accessLevel,
            isOwner: action.payload.accessLevel === ACCESS_LEVELS.OWNER
          },
          // Also update in the users array to ensure consistency
          users: state.users.map(user => 
            user.id === action.payload.userId
              ? { ...user, accessLevel: action.payload.accessLevel }
              : user
          )
        };
      }
      
      // If it's another user, update only in the users array
      return {
        ...state,
        users: state.users.map(user => 
          user.id === action.payload.userId 
            ? { ...user, accessLevel: action.payload.accessLevel }
            : user
        )
      };
      
    case ACTION_TYPES.ADD_CHAT_MESSAGE:
      return {
        ...state,
        chat: [...state.chat, action.payload]
      };
      
    case ACTION_TYPES.SET_CONNECTION_STATUS:
      return {
        ...state,
        connected: action.payload
      };
      
    case ACTION_TYPES.SET_ERROR:
      return {
        ...state,
        error: action.payload
      };
      
    case ACTION_TYPES.CLEAR_ERROR:
      return {
        ...state,
        error: null
      };
      
    default:
      return state;
  }
};

// Create room context
const RoomContext = createContext();

// Room provider component
export const RoomProvider = ({ children }) => {
  const [state, dispatch] = useReducer(roomReducer, initialState);
  const [socket, setSocket] = useState(null);
  const navigate = useNavigate();
  const auth = useSelector(state => state.auth);
  
  // Initialize Yjs document and connection
  const initializeYjs = useCallback((slug) => {
    // Create a new Yjs document
    const yDoc = new Y.Doc();
    
    // Define shared text for the code editor - use a name that Monaco binding will recognize
    const yText = yDoc.getText('monaco');
    
    // Connect to WebSocket server for Yjs updates
    const wsProtocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    const wsHost = import.meta.env.VITE_API_URL
      ? import.meta.env.VITE_API_URL.replace(/^https?:\/\//, '')
      : window.location.host;
      
    const wsUrl = `${wsProtocol}//${wsHost}/yjs`;
    
    // Create the provider with authentication
    const provider = new WebsocketProvider(wsUrl, slug, yDoc, {
      params: { 
        token: auth.token,
        room: slug
      },
      connect: true
    });
    
    // Add connection status events
    provider.on('status', event => {
      console.log('YJS connection status:', event.status);
      
      if (event.status === 'connected') {
        dispatch({
          type: ACTION_TYPES.SET_CONNECTION_STATUS,
          payload: true
        });
      } else {
        dispatch({
          type: ACTION_TYPES.SET_CONNECTION_STATUS,
          payload: false
        });
      }
    });
    
    // Log errors
    provider.on('connection-error', error => {
      console.error('YJS connection error:', error);
    });
    
    return { yDoc, yText, provider };
  }, [auth.token, dispatch]);
  
  // Initialize socket connection
  useEffect(() => {
    if (!auth.token) return;
    
    // Connect to socket
    const socketUrl = import.meta.env.VITE_API_URL || window.location.origin;
    const socketIo = io(`${socketUrl}/rooms`, {
      auth: {
        token: auth.token
      }
    });
    
    setSocket(socketIo);
    
    // Clean up
    return () => {
      if (socketIo) socketIo.disconnect();
    };
  }, [auth.token]);

  // Leave the current room
  const leaveRoom = useCallback(() => {
    try {
      if (state.slug && socket) {
        socket.emit('leave-room', { slug: state.slug });
      }
      
      dispatch({ type: ACTION_TYPES.LEAVE_ROOM });
      removeFromStorage('current_room');
      
      // Navigate to home
      navigate('/');
    } catch (error) {
      console.error('Error leaving room:', error);
    }
  }, [state.slug, socket, dispatch, navigate]);

  // Set up socket event listeners
  useEffect(() => {
    if (!socket) return;
    
    // Socket event listeners for room management
    socket.on('room-joined', (data) => {
      console.log("Room joined event received:", data);
      
      // Initialize Yjs for collaborative editing
      const { yDoc, yText, provider } = initializeYjs(data.slug);
      
      // Set up awareness for this user
      if (data.currentUser?.id) {
        provider.awareness.setLocalStateField('user', {
          id: data.currentUser.id,
          name: data.currentUser.displayName || data.currentUser.username || 'Anonymous',
          color: getUserColor(data.currentUser.id),
          accessLevel: data.currentUser.accessLevel
        });
      }
      
      dispatch({
        type: ACTION_TYPES.JOIN_ROOM_SUCCESS,
        payload: {
          ...data,
          yDoc,
          provider
        }
      });
      
      // Save slug to storage
      saveToStorage('current_room', data.slug);
      
      // If code exists, update the Yjs document
      if (data.code && yText.toString() === '') {
        // Insert the code with a transaction to avoid duplicate undo/redo history
        yDoc.transact(() => {
          yText.insert(0, data.code);
        });
      }
    });
    
    socket.on('error', (error) => {
      console.error("Room error received:", error);
      dispatch({
        type: ACTION_TYPES.JOIN_ROOM_ERROR,
        payload: error.message
      });
    });
    
    socket.on('user-joined', (user) => {
      console.log("User joined:", user);
      dispatch({
        type: ACTION_TYPES.UPDATE_USERS,
        payload: [...state.users, user]
      });
    });
    
    socket.on('user-left', (data) => {
      console.log("User left:", data);
      dispatch({
        type: ACTION_TYPES.UPDATE_USERS,
        payload: state.users.filter(user => user.id !== data.userId)
      });
    });
    
    socket.on('access-updated', (data) => {
      console.log("Access updated:", data);
      dispatch({
        type: ACTION_TYPES.UPDATE_ACCESS_LEVEL,
        payload: {
          userId: data.userId,
          accessLevel: data.accessLevel
        }
      });
    });
    
    socket.on('cursor-update', (data) => {
      dispatch({
        type: ACTION_TYPES.UPDATE_CURSORS,
        payload: {
          userId: data.userId,
          cursor: {
            position: data.position,
            selection: data.selection
          }
        }
      });
    });
    
    socket.on('chat-message', (message) => {
      dispatch({
        type: ACTION_TYPES.ADD_CHAT_MESSAGE,
        payload: message
      });
    });
    
    socket.on('room-left', () => {
      leaveRoom();
    });
    
    socket.on('disconnect', () => {
      dispatch({
        type: ACTION_TYPES.SET_CONNECTION_STATUS,
        payload: false
      });
    });
    
    socket.on('connect', () => {
      dispatch({
        type: ACTION_TYPES.SET_CONNECTION_STATUS,
        payload: true
      });
    });
    
    // Handle user being kicked from room
    socket.on('user-removed', ({ userId }) => {
      if (userId === state.currentUser.id) {
        dispatch({
          type: ACTION_TYPES.LEAVE_ROOM,
        });
        dispatch({
          type: ACTION_TYPES.SET_ERROR,
          payload: 'You have been removed from the room',
        });
      }
    });
    
    // Handle room closure
    socket.on('room-closed', ({ slug, message }) => {
      if (slug === state.slug) {
        dispatch({
          type: ACTION_TYPES.LEAVE_ROOM,
        });
        dispatch({
          type: ACTION_TYPES.SET_ERROR,
          payload: message || 'The room has been closed',
        });
      }
    });
    
    // Clean up
    return () => {
      socket.off('room-joined');
      socket.off('error');
      socket.off('user-joined');
      socket.off('user-left');
      socket.off('access-updated');
      socket.off('cursor-update');
      socket.off('chat-message');
      socket.off('room-left');
      socket.off('disconnect');
      socket.off('connect');
      socket.off('user-removed');
      socket.off('room-closed');
    };
  }, [socket, state.users, state.slug, state.currentUser, initializeYjs, leaveRoom, dispatch]);
  
  // Check if room already exists in local storage on mount
  useEffect(() => {
    const checkExistingRoom = async () => {
      const roomId = getFromStorage('current_room');
      const userName = getFromStorage('user_name');
      
      if (roomId && userName && socket) {
        // Only attempt to rejoin if we have both room ID and username
        // AND the page wasn't just refreshed (check URL parameters)
        const urlParams = new URLSearchParams(window.location.search);
        const isDirectNavigation = !urlParams.has('suppressRejoin');
        
        if (isDirectNavigation) {
          console.log(`Attempting to rejoin existing room: ${roomId} as ${userName}`);
          dispatch({ type: ACTION_TYPES.JOIN_ROOM_START });
          socket.emit('rejoin-room', { slug: roomId, userName });
        } else {
          // Clear the stored room if we're not rejoining
          localStorage.removeItem('current_room');
        }
      }
    };
    
    // Don't attempt to rejoin immediately on page load
    // Instead, wait a short time to ensure the socket is properly connected
    // and the user has had time to view the initial page
    if (socket) {
      const timer = setTimeout(() => {
        checkExistingRoom();
      }, 1500);
      
      return () => clearTimeout(timer);
    }
  }, [socket, dispatch]);
  
  // Room context actions
  const createRoom = async (roomData) => {
    try {
      dispatch({ type: ACTION_TYPES.JOIN_ROOM_START });
      
      if (!auth.token) {
        throw new Error('Authentication required');
      }
      
      // Create room via API
      const response = await api.rooms.createRoom(roomData);
      
      if (!response.data.success) {
        throw new Error(response.data.message || 'Failed to create room');
      }
      
      // Join the room via socket
      socket.emit('join-room', { slug: response.data.room.slug });
      
      // Navigate to the room page
      navigate(`/room/${response.data.room.slug}`);
      
      return response.data.room;
    } catch (error) {
      console.error('Error creating room:', error);
      dispatch({
        type: ACTION_TYPES.JOIN_ROOM_ERROR,
        payload: error.message || 'Failed to create room'
      });
      return null;
    }
  };
  
  // Join an existing room
  const joinRoom = async (slug) => {
    try {
      dispatch({ type: ACTION_TYPES.JOIN_ROOM_START });
      
      if (!auth.token) {
        throw new Error('Authentication required');
      }
      
      if (!slug) {
        throw new Error('Room slug is required');
      }
      
      // Check if room exists via API
      const response = await api.rooms.getRoomDetails(slug);
      
      if (!response.data.success || !response.data.roomExists) {
        throw new Error(response.data.message || 'Room not found');
      }
      
      // Join the room via socket
      socket.emit('join-room', { slug });
      
      return true;
    } catch (error) {
      console.error('Error joining room:', error);
      dispatch({
        type: ACTION_TYPES.JOIN_ROOM_ERROR,
        payload: error.message || 'Failed to join room'
      });
      return false;
    }
  };
  
  // Leave the current room
  const leaveRoom = useCallback(() => {
    try {
      if (state.slug && socket) {
        socket.emit('leave-room', { slug: state.slug });
      }
      
      dispatch({ type: ACTION_TYPES.LEAVE_ROOM });
      removeFromStorage('current_room');
      
      // Navigate to home
      navigate('/');
    } catch (error) {
      console.error('Error leaving room:', error);
    }
  }, [state.slug, socket, dispatch, navigate]);
  
  // Update user's cursor position
  const updateCursor = (position, selection) => {
    if (!state.slug || !socket) return;
    
    socket.emit('cursor-update', {
      slug: state.slug,
      position,
      selection
    });
  };
  
  // Update a user's access level
  const updateUserAccess = async (userId, accessLevel) => {
    try {
      if (!state.slug || !socket) {
        throw new Error('Not connected to a room');
      }
      
      if (!state.currentUser.isOwner) {
        throw new Error('Only the room owner can change access levels');
      }
      
      socket.emit('update-access', {
        slug: state.slug,
        userId,
        accessLevel
      });
      
      return true;
    } catch (error) {
      console.error('Error updating access level:', error);
      dispatch({
        type: ACTION_TYPES.SET_ERROR,
        payload: error.message
      });
      return false;
    }
  };
  
  // Send a chat message
  const sendChatMessage = (message) => {
    if (!state.slug || !socket || !message.trim()) return;
    
    socket.emit('chat-message', {
      slug: state.slug,
      message: message.trim()
    });
  };
  
  // Update room settings
  const updateRoomSettings = async (settings) => {
    try {
      if (!state.slug) {
        throw new Error('Not connected to a room');
      }
      
      if (!state.currentUser.isOwner) {
        throw new Error('Only the room owner can change room settings');
      }
      
      const response = await api.rooms.updateRoomSettings(state.slug, settings);
      
      if (!response.data.success) {
        throw new Error(response.data.message || 'Failed to update room settings');
      }
      
      dispatch({
        type: ACTION_TYPES.UPDATE_ROOM_DETAILS,
        payload: response.data.room
      });
      
      return true;
    } catch (error) {
      console.error('Error updating room settings:', error);
      dispatch({
        type: ACTION_TYPES.SET_ERROR,
        payload: error.message
      });
      return false;
    }
  };
  
  // Helper function to generate consistent color for a user
  const getUserColor = (userId) => {
    // Generate a deterministic color based on the userId
    const colors = [
      '#FF6B6B', '#4ECDC4', '#FFE66D', '#1A535C', '#F9C80E',
      '#FF8C42', '#A4036F', '#048BA8', '#16DB93', '#EFBCD5'
    ];

    // Use a simple hash of the userId to pick a color
    const hash = String(userId).split('').reduce((acc, char) => {
      return acc + char.charCodeAt(0);
    }, 0);

    return colors[hash % colors.length];
  };
  
  // Context value
  const value = {
    ...state,
    createRoom,
    joinRoom,
    leaveRoom,
    updateCursor,
    updateUserAccess,
    sendChatMessage,
    updateRoomSettings,
    canEdit: state.currentUser ? canEdit(state.currentUser.accessLevel) : false,
    canRun: state.currentUser ? canRun(state.currentUser.accessLevel) : false,
    canManageUsers: state.currentUser ? canManageUsers(state.currentUser.accessLevel) : false
  };
  
  return (
    <RoomContext.Provider value={value}>
      {children}
    </RoomContext.Provider>
  );
};

// Custom hook to use room context
export const useRoom = () => {
  const context = useContext(RoomContext);
  
  if (!context) {
    throw new Error('useRoom must be used within a RoomProvider');
  }
  
  return context;
};
